<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>java并发基本知识的简单介绍（二）</title>
      <link href="/posts/cb6bee02.html"/>
      <url>/posts/cb6bee02.html</url>
      
        <content type="html"><![CDATA[<h2 id="共享资源带来的问题"><a href="#共享资源带来的问题" class="headerlink" title="共享资源带来的问题"></a>共享资源带来的问题</h2><p><strong>临界区 Critical Section</strong></p><ul><li>一个程序运行多个线程本身是没有问题的</li><li>问题出在多个线程访问<strong>共享资源</strong><ul><li>多个线程读<strong>共享资源</strong>其实也没有问题</li><li>在多个线程对<strong>共享资源</strong>读写操作时发生指令交错，就会出现问题</li></ul></li><li>一段代码块内如果存在对<strong>共享资源</strong>的<font color="red">多线程读写操作 </font>，称这段代码块为<strong>临界区</strong></li></ul><p><strong>竞态条件 Race Condition</strong></p><p>多个线程在临界区内执行，由于代码的<strong>执行序列不同</strong>而导致结果无法预测，称之为发生了<strong>竞态条件</strong></p><h2 id="synchronized-解决方案"><a href="#synchronized-解决方案" class="headerlink" title="synchronized 解决方案"></a>synchronized 解决方案</h2><p>为了避免临界区的竞态条件发生，有多种手段可以达到目的。</p><ul><li>阻塞式的解决方案：synchronized，Lock</li><li>非阻塞式的解决方案：原子变量</li></ul><p>本文使用阻塞式的解决方案：synchronized，来解决上述问题，即俗称的【对象锁】，它采用互斥的方式让同一</p><p>时刻至多只有一个线程能持有【对象锁】，其它线程再想获取这个【对象锁】时就会阻塞住。这样就能保证拥有锁</p><p>的线程可以安全的执行临界区内的代码，不用担心线程上下文切换</p><div class="note green no-icon flat"><p><strong>注意</strong></p><p>虽然 java 中互斥和同步都可以采用 synchronized 关键字来完成，但它们还是有区别的：</p><ul><li>互斥是保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区代码</li><li>同步是由于线程执行的先后、顺序不同、需要一个线程等待其它线程运行到某个点</li></ul></div><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>语法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(对象) <span class="comment">// 线程1，线程2(blocked)</span></span><br><span class="line">&#123;</span><br><span class="line">临界区</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (MySynchronized.class) &#123;</span><br><span class="line">                ++counter;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (MySynchronized.class) &#123;</span><br><span class="line">                --counter;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;t2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">&quot;counter=&#123;&#125;&quot;</span>, counter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用图来表示：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ysxnote.oss-cn-hangzhou.aliyuncs.com/imgs/posts/synchronized.png" alt="synchronized在程序运行过程中的作用" style="zoom:50%;"></p><p>synchronized 实际是用<strong>对象锁</strong>保证了<strong>临界区内代码的原子性</strong>，临界区内的代码对外是不可分割的，不会被线程切</p><p>换所打断。</p><p><strong>面向对象改进</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 把需要保护的共享变量放入一个类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Room</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            ++value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            --value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Room</span> <span class="variable">room</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Room</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            room.increment();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            room.decrement();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;t2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">&quot;counter=&#123;&#125;&quot;</span>, room.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="变量的线程安全分析"><a href="#变量的线程安全分析" class="headerlink" title="变量的线程安全分析"></a>变量的线程安全分析</h2><p><strong>成员变量和静态变量是否线程安全？</strong></p><ul><li><p>如果它们没有共享，则线程安全</p></li><li><p>如果它们被共享了，根据它们的状态是否能够改变，又分两种情况</p></li><li><ul><li>如果只有读操作，则线程安全</li><li>如果有读写操作，则这段代码是临界区，需要考虑线程安全</li></ul></li></ul><p><strong>局部变量是否线程安全？</strong></p><ul><li><p>局部变量是线程安全的</p></li><li><p>但局部变量引用的对象则未必</p></li><li><ul><li>如果该对象没有逃离方法的作用访问，它是线程安全的</li><li>如果该对象逃离方法的作用范围，需要考虑线程安全</li></ul></li></ul><p><strong>常见线程安全类</strong></p><ul><li>String</li><li>Integer</li><li>StringBuffer</li><li>Random</li><li>Vector</li><li>Hashtable</li><li>java.util.concurrent 包下的类</li></ul><p>这里说它们是线程安全的是指，多个线程调用它们同一个实例的某个方法时，是线程安全的。</p><div class="note green no-icon flat"><ul><li>它们的每个方法是原子的</li><li>但注意它们多个方法的组合不是原子的</li></ul></div><p><strong>不可变类线程安全性</strong></p><p>String、Integer 等都是不可变类，因为其内部的状态不可以改变，因此它们的方法都是线程安全的。</p><p><strong>如何设计一个不可变类?</strong></p><ul><li><p>使类中所有的成员变量被final修饰</p></li><li><p>类中没有修改成员变量的方法,例如setXXX,可以提供一个带参的构造函数来初始化这些成员变量</p></li><li><p>确保类中的方法不会被重写.可以将类或者类中的方法定义为final的来实现</p></li><li><p>如果一个类的成员不是不可变量,那么在成员初始化或者使用get方法获取该成员变量时,需要使用clone方法来确保类的不可变性</p></li></ul><h2 id="Monitor-概念"><a href="#Monitor-概念" class="headerlink" title="Monitor 概念"></a>Monitor 概念</h2><h3 id="Java-对象头"><a href="#Java-对象头" class="headerlink" title="Java 对象头"></a>Java 对象头</h3><p>以 32 位虚拟机为例</p><p>普通对象</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ysxnote.oss-cn-hangzhou.aliyuncs.com/imgs/posts/java-head1.png" alt="普通对象的java头" style="zoom:70%;"></p><p>数组对象</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ysxnote.oss-cn-hangzhou.aliyuncs.com/imgs/posts/java-head2.png" alt="数组对象的java头" style="zoom:70%;"></p><p>其中 Mark Word 结构为</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ysxnote.oss-cn-hangzhou.aliyuncs.com/imgs/posts/java-head3.png" alt="Mark Word结构" style="zoom:70%;"></p><p>64 位虚拟机 Mark Word</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ysxnote.oss-cn-hangzhou.aliyuncs.com/imgs/posts/java-head4.png" alt="64位虚拟机 Mark Word" style="zoom:100%;"></p><h3 id="Monitor-原理"><a href="#Monitor-原理" class="headerlink" title="Monitor 原理"></a>Monitor 原理</h3><p>Monitor 被翻译为监视器或<strong>管程</strong></p><p>每个 Java 对象都可以关联一个 Monitor 对象，如果使用 <strong>synchronized</strong> 给对象上锁（<strong>重量级</strong>）之后，该对象头的Mark Word 中就被设置指向 Monitor 对象的指针</p><p>Monitor 结构如下</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ysxnote.oss-cn-hangzhou.aliyuncs.com/imgs/posts/monitor1.png" alt="Monitor 结构" style="zoom:90%;"></p><ul><li>刚开始Monitor中Owner为null</li><li>当Thread-2执行synchronized(obj)就会将Monitor的所有者Owner置为Thread-2, Monitor中只能有一个Owner</li><li>在Thread-2上锁的过程中，如果Thread-3, Thread-4, Thread-5也来执行synchronized(obj)， 就会进入EntryList BLOCKED </li><li>Thread-2执行完同步代码块的内容， 然后唤醒EntryL ist中等待的线程来竞争锁，竞争的时是非公平的</li><li>图中WaitSet中的Thread-0， Thread-1是之前获得过锁，但条件不满足进入WAITING状态的线程，后面讲wait-notify时会分析</li></ul><div class="note green no-icon flat"><p><strong>注意:</strong></p><ul><li>synchronized必须是进入同一个对象的monitor才有上述的效果</li><li>不加synchronized的对象不会关联监视器，不遵从以上规则</li></ul></div><h2 id="synchronized-原理"><a href="#synchronized-原理" class="headerlink" title="synchronized 原理"></a>synchronized 原理</h2><p>略，从字节码指令分析</p><h2 id="synchronized-原理进阶"><a href="#synchronized-原理进阶" class="headerlink" title="synchronized 原理进阶"></a>synchronized 原理进阶</h2><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>轻量级锁的使用场景：如果一个对象虽然有多线程要加锁，但加锁的时间是错开的（也就是没有竞争），那么可以使用轻量级锁来优化。</p><p>轻量级锁对使用者是透明的，即语法仍然是 synchronized</p><p>假设有两个方法同步块，利用同一个对象加锁</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>( obj ) &#123;</span><br><span class="line">    <span class="comment">// 同步块 A</span></span><br><span class="line">    method2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>( obj ) &#123;</span><br><span class="line">    <span class="comment">// 同步块 B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>创建锁记录（Lock Record）对象，每个线程都的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的Mark Word</li></ol><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ysxnote.oss-cn-hangzhou.aliyuncs.com/imgs/posts/lightweight-lock1.png" alt="加锁过程1" style="zoom:60%;"></p><ol><li>让锁记录中 Object reference 指向锁对象，并尝试用 cas 替换 Object 的 Mark Word，将 Mark Word 的值存入锁记录</li></ol><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ysxnote.oss-cn-hangzhou.aliyuncs.com/imgs/posts/lightweight-lock2.png" alt="加锁过程2" style="zoom:60%;"></p><ol><li><p>如果 cas 替换成功，对象头中存储了锁记录地址和状态 00 ，表示由该线程给对象加锁，这时图示如下</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ysxnote.oss-cn-hangzhou.aliyuncs.com/imgs/posts/lightweight-lock3.png" alt="加锁过程3" style="zoom:60%;"></p></li><li><p>如果 cas 失败，有两种情况</p><ul><li>如果是其它线程已经持有了该 Object     的轻量级锁，这时表明有竞争，进入锁膨胀过程</li><li>如果是自己执行了 synchronized     锁重入，那么再添加一条 Lock Record 作为重入的计数</li></ul></li></ol><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ysxnote.oss-cn-hangzhou.aliyuncs.com/imgs/posts/lightweight-lock4.png" alt="加锁过程4" style="zoom:60%;"></p><ol><li>当退出 synchronized 代码块（解锁时）如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重</li></ol><p>入计数减一</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/cb6bee02.htm/blog\imgs\posts\lightweight-lock5.png" alt="加锁过程5" style="zoom:67%;"></p><ol><li><p>当退出 synchronized 代码块（解锁时）锁记录的值不为 null，这时使用 CAS 将 Mark Word 的值恢复给对象头</p><ul><li><p>成功，则解锁成功</p></li><li><p>失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</p></li></ul></li></ol><h3 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h3><p>如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁。</p><ol><li>当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁</li></ol><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ysxnote.oss-cn-hangzhou.aliyuncs.com/imgs/posts/inflation-lock1.png" alt="加锁过程1"></p><ol><li><p>这时 Thread-1 加轻量级锁失败，进入锁膨胀流程</p><ul><li><p>即为 Object 对象申请 Monitor 锁，让     Object 指向重量级锁地址</p></li><li><p>然后自己进入 Monitor 的 EntryList     BLOCKED</p></li></ul></li></ol><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ysxnote.oss-cn-hangzhou.aliyuncs.com/imgs/posts/inflation-lock2.png" alt="加锁过程2"></p><ol><li>当 Thread-0 退出同步块解锁时，使用 cas 将 Mark Word 的值恢复给对象头，失败。这时会进入重量级解锁流程，即按照 Monitor 地址找到 Monitor 对象，设置 Owner 为 null，唤醒 EntryList 中 BLOCKED 线程</li></ol><h3 id="自旋优化"><a href="#自旋优化" class="headerlink" title="自旋优化"></a>自旋优化</h3><p>重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞。</p><div class="note green no-icon flat"><p><strong>注意</strong>：</p><ul><li>自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。</li><li>在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。</li><li>Java 7 之后不能控制是否开启自旋功能</li></ul></div><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行 CAS 操作。</p><p>Java 6 中引入了偏向锁来做进一步优化：只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有</p><p>例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(obj) &#123;</span><br><span class="line">        <span class="comment">// 同步块 A</span></span><br><span class="line">        m2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(obj) &#123;</span><br><span class="line">        <span class="comment">// 同步块 B</span></span><br><span class="line">        m3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(obj) &#123;</span><br><span class="line">        <span class="comment">// 同步块 C</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="偏向状态"><a href="#偏向状态" class="headerlink" title="偏向状态"></a>偏向状态</h4><p>回忆一下对象头格式</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ysxnote.oss-cn-hangzhou.aliyuncs.com/imgs/posts/java-head4.png" alt="64位虚拟机 Mark Word" style="zoom:100%;"></p><p>一个对象创建时：</p><ul><li>如果开启了偏向锁（<font color="red">默认开启</font>），那么对象创建后，markword     值为 0x05 即最后 3 位为 101，这时它的 thread、epoch、age 都为 0</li><li>偏向锁是默认是延迟的，不会在程序启动时立即生效，如果想避免延迟，可以加VM 参数 -XX:BiasedLockingStartupDelay=0 来禁用延迟</li><li>如果没有开启偏向锁，那么对象创建后，markword 值为     0x01 即最后 3 位为 001，这时它的 hashcode、age 都为 0，第一次用到 hashcode 时才会赋值</li></ul><h5 id="测试延迟特性"><a href="#测试延迟特性" class="headerlink" title="测试延迟特性"></a>测试延迟特性</h5><p>偏向锁是默认是延迟的，不会在程序启动时立即生效</p><h5 id="测试偏向锁"><a href="#测试偏向锁" class="headerlink" title="测试偏向锁"></a>测试偏向锁</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">People</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">People</span>();</span><br><span class="line">    <span class="type">ClassLayout</span> <span class="variable">classLayout</span> <span class="operator">=</span> ClassLayout.parseInstance(p);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;synchronized 前&quot;</span>);</span><br><span class="line">        System.out.println(classLayout.toPrintable(<span class="literal">true</span>));</span><br><span class="line">        <span class="keyword">synchronized</span> (p) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;synchronized 中&quot;</span>);</span><br><span class="line">            System.out.println(classLayout.toPrintable(<span class="literal">true</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;synchronized 后&quot;</span>);</span><br><span class="line">        System.out.println(classLayout.toPrintable(<span class="literal">true</span>));</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note green no-icon flat"><p><strong>注意</strong><br>处于偏向锁的对象解锁后，线程 id 仍存储于对象头中</p></div><h5 id="测试禁用"><a href="#测试禁用" class="headerlink" title="测试禁用"></a>测试禁用</h5><p>添加 VM 参数 -XX:-UseBiasedLocking 禁用偏向锁</p><h5 id="测试-hashCode"><a href="#测试-hashCode" class="headerlink" title="测试 hashCode"></a>测试 hashCode</h5><p>正常状态对象一开始是没有 hashCode 的，第一次调用才生成</p><h4 id="撤销-调用对象-hashCode"><a href="#撤销-调用对象-hashCode" class="headerlink" title="撤销 - 调用对象 hashCode"></a>撤销 - 调用对象 hashCode</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">People</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">People</span>();</span><br><span class="line">    <span class="comment">// 调用 hashCode 会导致偏向锁被撤销</span></span><br><span class="line">    p.hashCode();</span><br><span class="line"></span><br><span class="line">    log.debug(ClassLayout.parseInstance(p).toPrintable());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (p) &#123;</span><br><span class="line">        log.debug(ClassLayout.parseInstance(<span class="keyword">new</span> <span class="title class_">People</span>()).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">    log.debug(ClassLayout.parseInstance(<span class="keyword">new</span> <span class="title class_">People</span>()).toPrintable());    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用了对象的 hashCode，但偏向锁的对象 MarkWord 中存储的是线程 id，如果调用 hashCode 会导致偏向锁被撤销</p><ul><li>轻量级锁会在锁记录中记录 hashCode</li><li>重量级锁会在 Monitor 中记录 hashCode</li></ul><p>在调用 hashCode 后使用偏向锁，记得去掉 -XX:-UseBiasedLocking</p><h4 id="撤销-其它线程使用对象"><a href="#撤销-其它线程使用对象" class="headerlink" title="撤销 - 其它线程使用对象"></a>撤销 - 其它线程使用对象</h4><p>当有其它线程使用偏向锁对象时，会将偏向锁升级为轻量级锁</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">People</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">People</span>();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (p) &#123;</span><br><span class="line">            log.debug(ClassLayout.parseInstance(p).toPrintable(<span class="literal">true</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (MyBiasedLock.class) &#123;</span><br><span class="line">            MyBiasedLock.class.notify();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果不用 wait/notify 使用 join 必须打开下面的注释</span></span><br><span class="line">        <span class="comment">// 因为：t1 线程不能结束，否则底层线程可能被 jvm 重用作为 t2 线程，底层线程 id 是一样的</span></span><br><span class="line">        <span class="comment">/*try &#123;</span></span><br><span class="line"><span class="comment">            System.in.read();</span></span><br><span class="line"><span class="comment">            &#125; catch (IOException e) &#123;</span></span><br><span class="line"><span class="comment">            e.printStackTrace();</span></span><br><span class="line"><span class="comment">         &#125;*/</span></span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (MyBiasedLock.class) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                MyBiasedLock.class.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(ClassLayout.parseInstance(p).toPrintable(<span class="literal">true</span>));</span><br><span class="line">        <span class="keyword">synchronized</span> (p) &#123;</span><br><span class="line">            log.debug(ClassLayout.parseInstance(p).toPrintable(<span class="literal">true</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(ClassLayout.parseInstance(p).toPrintable(<span class="literal">true</span>));</span><br><span class="line">    &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="撤销-调用-wait-notify"><a href="#撤销-调用-wait-notify" class="headerlink" title="撤销 - 调用 wait/notify"></a>撤销 - 调用 wait/notify</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">People</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">People</span>();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        log.debug(ClassLayout.parseInstance(p).toPrintable(<span class="literal">true</span>));</span><br><span class="line">        <span class="keyword">synchronized</span> (p) &#123;</span><br><span class="line">            log.debug(ClassLayout.parseInstance(p).toPrintable(<span class="literal">true</span>));</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                p.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(ClassLayout.parseInstance(p).toPrintable(<span class="literal">true</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">6000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (p) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;notify&quot;</span>);</span><br><span class="line">            p.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="批量重偏向"><a href="#批量重偏向" class="headerlink" title="批量重偏向"></a>批量重偏向</h4><p>如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，重偏向会重置对象的 Thread ID</p><p>当撤销偏向锁阈值超过 20 次后，jvm 会这样觉得，我是不是偏向错了呢，于是会在给这些对象加锁时重新偏向至加锁线程</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    Vector&lt;People&gt; list = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">            <span class="type">People</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">People</span>();</span><br><span class="line">            list.add(p);</span><br><span class="line">            <span class="keyword">synchronized</span> (p) &#123;</span><br><span class="line">                log.debug(i + <span class="string">&quot;\t&quot;</span> + ClassLayout.parseInstance(p).toPrintable(<span class="literal">true</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">            list.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                list.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;===============&gt; &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">            <span class="type">People</span> <span class="variable">p</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">            log.debug(i + <span class="string">&quot;\t&quot;</span> + ClassLayout.parseInstance(p).toPrintable(<span class="literal">true</span>));</span><br><span class="line">            <span class="keyword">synchronized</span> (p) &#123;</span><br><span class="line">                log.debug(i + <span class="string">&quot;\t&quot;</span> + ClassLayout.parseInstance(p).toPrintable(<span class="literal">true</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(i + <span class="string">&quot;\t&quot;</span> + ClassLayout.parseInstance(p).toPrintable(<span class="literal">true</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="批量撤销"><a href="#批量撤销" class="headerlink" title="批量撤销"></a>批量撤销</h4><p>当撤销偏向锁阈值超过 40 次后，jvm 会这样觉得，自己确实偏向错了，根本就不该偏向。于是整个类的所有对象都会变为不可偏向的，新建的对象也是不可偏向的</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    Vector&lt;People&gt; list = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">loopNumber</span> <span class="operator">=</span> <span class="number">39</span>;</span><br><span class="line">    t1 = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            <span class="type">People</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">People</span>();</span><br><span class="line">            list.add(p);</span><br><span class="line">            <span class="keyword">synchronized</span> (p) &#123;</span><br><span class="line">                log.debug(i + <span class="string">&quot;\t&quot;</span> + ClassLayout.parseInstance(p).toPrintable(<span class="literal">true</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        LockSupport.unpark(t2);</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2 = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        LockSupport.park();</span><br><span class="line">        log.debug(<span class="string">&quot;===============&gt; &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            <span class="type">People</span> <span class="variable">p</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">            log.debug(i + <span class="string">&quot;\t&quot;</span> + ClassLayout.parseInstance(p).toPrintable(<span class="literal">true</span>));</span><br><span class="line">            <span class="keyword">synchronized</span> (p) &#123;</span><br><span class="line">                log.debug(i + <span class="string">&quot;\t&quot;</span> + ClassLayout.parseInstance(p).toPrintable(<span class="literal">true</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(i + <span class="string">&quot;\t&quot;</span> + ClassLayout.parseInstance(p).toPrintable(<span class="literal">true</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        LockSupport.unpark(t3);</span><br><span class="line">    &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">    t2.start();</span><br><span class="line">    t3 = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        LockSupport.park();</span><br><span class="line">        log.debug(<span class="string">&quot;===============&gt; &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            <span class="type">People</span> <span class="variable">p</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">            log.debug(i + <span class="string">&quot;\t&quot;</span> + ClassLayout.parseInstance(p).toPrintable(<span class="literal">true</span>));</span><br><span class="line">            <span class="keyword">synchronized</span> (p) &#123;</span><br><span class="line">                log.debug(i + <span class="string">&quot;\t&quot;</span> + ClassLayout.parseInstance(p).toPrintable(<span class="literal">true</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(i + <span class="string">&quot;\t&quot;</span> + ClassLayout.parseInstance(p).toPrintable(<span class="literal">true</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;t3&quot;</span>);</span><br><span class="line">    t3.start();</span><br><span class="line">    t3.join();</span><br><span class="line">    log.debug(ClassLayout.parseInstance(<span class="keyword">new</span> <span class="title class_">People</span>()).toPrintable(<span class="literal">true</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>JIT编译器在编译的时候，进行逃逸分析。分析synchronized锁对象是不是只可能被一个线程加锁，不存在其他线程来竞争加锁的情况。这时就可以消除该锁了，提升执行效率。</p><p>编译就不用加入monitorenter和monitorexit指令。</p><p>去掉锁消除：-XX:-EliminateLocks</p><h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>对相同对象多次加锁，导致线程发生多次重入，可以使用锁粗化方式来优化，这不同于之前讲的细分锁的粒度</p><h2 id="wait-notify"><a href="#wait-notify" class="headerlink" title="wait notify"></a>wait notify</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ysxnote.oss-cn-hangzhou.aliyuncs.com/imgs/posts/wait-notify1.png" alt="wait-notify"></p><ul><li>Owner 线程发现条件不满足，调用 wait 方法，即可进入     WaitSet 变为 WAITING 状态</li><li>BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用     CPU 时间片</li><li>BLOCKED 线程会在 Owner 线程释放锁时唤醒</li><li>WAITING 线程会在 Owner 线程调用 notify 或     notifyAll 时唤醒，但唤醒后并不意味者立刻获得锁，仍需进入EntryList 重新竞争</li></ul><h3 id="API-介绍"><a href="#API-介绍" class="headerlink" title="API 介绍"></a>API 介绍</h3><font color="red">obj.wait()</font> 让进入 object 监视器的线程到 waitSet 等待<font color="red">obj.notify()</font> 在 object 上正在 waitSet 等待的线程中挑一个唤醒<font color="red">obj.notifyAll()</font> 让 object 上正在 waitSet 等待的线程全部唤醒<div class="note green no-icon flat"><p><strong>注意</strong></p><p>它们都是线程之间进行协作的手段，都属于 Object 对象的方法。必须获得此对象的锁，才能调用这几个方法</p></div>code:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;start1&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">&quot;end1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;start2&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">&quot;end2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;t2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="comment">// 唤醒其中一个线程</span></span><br><span class="line">        lock.notify();</span><br><span class="line">        <span class="comment">// 唤醒所有线程</span></span><br><span class="line">        <span class="comment">// lock.notifyAll();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><font color="red">wait()</font> 方法会释放对象的锁，进入 WaitSet 等待区，从而让其他线程就机会获取对象的锁。无限制等待，直到notify 为止<font color="red">wait(long n)</font> 有时限的等待, 到 n 毫秒后结束等待，或是被 notify**sleep(long n) 和 wait(long n) 的区别**1. sleep 是 Thread 方法，而 wait 是 Object 的方法 2. sleep 不需要强制和 synchronized 配合使用，但 wait 需要和 synchronized 一起用 3.  <font color="red">sleep 在睡眠的同时，不会释放对象锁的，但 wait 在等待的时候会释放对象锁</font> <ol><li>它们状态 TIMED_WAITING</li></ol><h3 id="模式-保护性暂停"><a href="#模式-保护性暂停" class="headerlink" title="模式: 保护性暂停"></a>模式: 保护性暂停</h3><p><strong>定义</strong><br>即 Guarded Suspension，用在一个线程等待另一个线程的执行结果<br><strong>要点</strong></p><ul><li>有一个结果需要从一个线程传递到另一个线程，让他们关联同一个 GuardedObject</li><li>如果有结果不断从一个线程到另一个线程那么可以使用消息队列（见生产者/消费者）</li><li>JDK 中，join 的实现、Future 的实现，采用的就是此模式</li><li>因为要等待另一方的结果，因此归类到同步模式</li></ul><p><strong>实现</strong></p><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">简单版</button></li><li class="tab"><button type="button" data-href="#test-2">带超时版</button></li><li class="tab"><button type="button" data-href="#test-3">多任务版</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GuardedObject</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">response</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getResponse</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">while</span> (response == <span class="literal">null</span>) &#123;</span><br><span class="line">                lock.wait();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setResponse</span><span class="params">(Object response)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="built_in">this</span>.response = response;</span><br><span class="line">            lock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">GuardedObject</span> <span class="variable">guardedObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GuardedObject</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t1&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Object</span> <span class="variable">response</span> <span class="operator">=</span> guardedObject.getResponse();</span><br><span class="line">                log.debug((String) response);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line"></span><br><span class="line">    log.debug(<span class="string">&quot;start transfer&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t2&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            guardedObject.setResponse(<span class="string">&quot;1234&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GuardedObjectTimeout</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">response</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">timeout</span> <span class="operator">=</span> <span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getResponse</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            <span class="type">long</span> <span class="variable">spendTime</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (response == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">timeWait</span> <span class="operator">=</span> timeout - spendTime;</span><br><span class="line">                <span class="keyword">if</span> (timeWait &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 这里需要虚假唤醒之后还需要等待的时间，并不是总的等待时间</span></span><br><span class="line">                lock.wait(timeWait);</span><br><span class="line">                spendTime = System.currentTimeMillis() - start;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setResponse</span><span class="params">(Object response)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="built_in">this</span>.response = response;</span><br><span class="line">            lock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">GuardedObjectTimeout</span> <span class="variable">guardedObjectTimeout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GuardedObjectTimeout</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t1&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Object</span> <span class="variable">response</span> <span class="operator">=</span> guardedObjectTimeout.getResponse();</span><br><span class="line">                log.debug((String) response);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line"></span><br><span class="line">    log.debug(<span class="string">&quot;start transfer&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t2&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 虚假唤醒</span></span><br><span class="line">            guardedObjectTimeout.setResponse(<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line"></span><br><span class="line">    t1.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-3"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GuardedObjectTimeout</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">response</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GuardedObjectTimeout</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getResponse</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            <span class="type">long</span> <span class="variable">spendTime</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (response == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">timeWait</span> <span class="operator">=</span> timeout - spendTime;</span><br><span class="line">                <span class="keyword">if</span> (timeWait &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 这里需要虚假唤醒之后还需要等待的时间，并不是总的等待时间</span></span><br><span class="line">                lock.wait(timeWait);</span><br><span class="line">                spendTime = System.currentTimeMillis() - start;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setResponse</span><span class="params">(Object response)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="built_in">this</span>.response = response;</span><br><span class="line">            lock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中间类，用于解耦</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PostBox</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Hashtable&lt;Integer, GuardedObjectTimeout&gt; box = <span class="keyword">new</span> <span class="title class_">Hashtable</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Integer&gt; <span class="title function_">getIds</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> box.keySet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">generateId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GuardedObjectTimeout <span class="title function_">addGO</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">GuardedObjectTimeout</span> <span class="variable">go</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GuardedObjectTimeout</span>(generateId());</span><br><span class="line">        box.put(go.getId(), go);</span><br><span class="line">        <span class="keyword">return</span> go;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GuardedObjectTimeout <span class="title function_">removeGO</span><span class="params">(<span class="type">int</span> id)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> box.remove(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">GuardedObjectTimeout</span> <span class="variable">guardedObject</span> <span class="operator">=</span> PostBox.addGO();</span><br><span class="line">        log.debug(<span class="string">&quot;开始收邮件id:&quot;</span> + guardedObject.getId());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">post</span> <span class="operator">=</span> guardedObject.getResponse(<span class="number">3000</span>);</span><br><span class="line">            log.debug(<span class="string">&quot;收到邮件id:&quot;</span> + guardedObject.getId() + <span class="string">&quot; 内容:&quot;</span> + post);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PostMen</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String post;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PostMen</span><span class="params">(<span class="type">int</span> id, String post)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.post = post;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">GuardedObjectTimeout</span> <span class="variable">guardedObject</span> <span class="operator">=</span> PostBox.removeGO(id);</span><br><span class="line">        log.debug(<span class="string">&quot;送邮件id:&quot;</span> + guardedObject.getId() + <span class="string">&quot; 内容:&quot;</span> + post);</span><br><span class="line">        guardedObject.setResponse(post);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">People</span>(), <span class="string">&quot;t&quot;</span> + (i+<span class="number">1</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Integer id : PostBox.getIds()) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">PostMen</span>(id, id + <span class="string">&quot;haha&quot;</span> + id), <span class="string">&quot;post_id&quot;</span>+id).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h4 id="join-原理"><a href="#join-原理" class="headerlink" title="join 原理"></a>join 原理</h4><p>是调用者轮询检查线程 alive 状态</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note green no-icon flat"><p><strong>注意</strong></p><p>join 体现的是【保护性暂停】模式</p></div><h3 id="模式-生产者消费者"><a href="#模式-生产者消费者" class="headerlink" title="模式: 生产者消费者"></a>模式: 生产者消费者</h3><p>实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> Object obj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Message</span><span class="params">(<span class="type">int</span> id, Object obj)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getObj</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Message&#123;id = &quot;</span> + id + <span class="string">&quot;, obj = &quot;</span> + obj + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerAndCustomer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Message&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProducerAndCustomer</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Message <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">            <span class="keyword">while</span> (list.isEmpty()) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;没货了, wait&quot;</span>);</span><br><span class="line">                list.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> list.removeFirst();</span><br><span class="line">            list.notifyAll();</span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(Message message)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">            <span class="keyword">while</span> (list.size() == <span class="built_in">this</span>.capacity) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;库存已达上限, wait&quot;</span>);</span><br><span class="line">                list.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(message);</span><br><span class="line">            list.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerAndCustomerTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ProducerAndCustomer</span> <span class="variable">pac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProducerAndCustomer</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    pac.put(<span class="keyword">new</span> <span class="title class_">Message</span>(id, <span class="string">&quot;123321&quot;</span>));</span><br><span class="line">                    log.info(<span class="string">&quot;放入一个消息&quot;</span>+id);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,<span class="string">&quot;product&quot;</span> + (i+<span class="number">1</span>)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> pac.take();</span><br><span class="line">                    log.info(message.toString());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;customer&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Park-amp-Unpark"><a href="#Park-amp-Unpark" class="headerlink" title="Park &amp; Unpark"></a>Park &amp; Unpark</h2><p>注：类似信号量</p><p><strong>基本使用</strong></p><p>它们是 LockSupport 类中的方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 暂停当前线程</span></span><br><span class="line">LockSupport.park();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 恢复某个线程的运行</span></span><br><span class="line">LockSupport.unpark(暂停线程对象)</span><br></pre></td></tr></table></figure><ul><li>先 park 再 unpark</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    log.debug(<span class="string">&quot;park...&quot;</span>);</span><br><span class="line">    LockSupport.park();</span><br><span class="line">    log.debug(<span class="string">&quot;resume...&quot;</span>);</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">2</span>);</span><br><span class="line">log.debug(<span class="string">&quot;unpark...&quot;</span>);</span><br><span class="line">LockSupport.unpark(t1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// 18:42:52.585 c.TestParkUnpark [t1] - start...</span></span><br><span class="line"><span class="comment">// 18:42:53.589 c.TestParkUnpark [t1] - park...</span></span><br><span class="line"><span class="comment">// 18:42:54.583 c.TestParkUnpark [main] - unpark...</span></span><br><span class="line"><span class="comment">// 18:42:54.583 c.TestParkUnpark [t1] - resume...</span></span><br></pre></td></tr></table></figure><ul><li>先 unpark 再 park</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    log.debug(<span class="string">&quot;park...&quot;</span>);</span><br><span class="line">    LockSupport.park();</span><br><span class="line">    log.debug(<span class="string">&quot;resume...&quot;</span>);</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">log.debug(<span class="string">&quot;unpark...&quot;</span>);</span><br><span class="line">LockSupport.unpark(t1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// 18:43:50.765 c.TestParkUnpark [t1] - start...</span></span><br><span class="line"><span class="comment">// 18:43:51.764 c.TestParkUnpark [main] - unpark...</span></span><br><span class="line"><span class="comment">// 18:43:52.769 c.TestParkUnpark [t1] - park...</span></span><br><span class="line"><span class="comment">// 18:43:52.769 c.TestParkUnpark [t1] - resume...</span></span><br></pre></td></tr></table></figure><p><strong>特点</strong></p><p>与 Object 的 wait &amp; notify 相比</p><ul><li>wait，notify 和 notifyAll 必须配合     Object Monitor 一起使用，而 park，unpark 不必</li><li>park &amp; unpark     是以线程为单位来【阻塞】和【唤醒】线程，而 notify 只能随机唤醒一个等待线程，notifyAll是唤醒所有等待线程，就不那么【精确】</li><li>park &amp; unpark 可以先 unpark，而     wait &amp; notify 不能先 notify</li></ul><h2 id="重新理解线程状态转换"><a href="#重新理解线程状态转换" class="headerlink" title="重新理解线程状态转换"></a>重新理解线程状态转换</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ysxnote.oss-cn-hangzhou.aliyuncs.com/imgs/posts/java-status.png" alt="Java API层面描述的六种状态" width="80%"></p><p>假设有线程 Thread t</p><p><strong>情况 1 NEW —&gt; RUNNABLE</strong></p><p>当调用 t.start() 方法时，由 NEW —&gt; RUNNABLE</p><p><strong>情况 2 RUNNABLE &lt;—&gt; WAITING</strong></p><p>t 线程用 synchronized(obj) 获取了对象锁后</p><ul><li><p>调用 obj.wait() 方法时，t 线程从 RUNNABLE —&gt; WAITING</p></li><li><p>调用 obj.notify() ，obj.notifyAll() ， t.interrupt() 时</p></li><li><ul><li>竞争锁成功，t 线程从 WAITING —&gt;  RUNNABLE</li><li>竞争锁失败，t 线程从 WAITING —&gt;   BLOCKED</li></ul></li></ul><p><strong>情况 3 RUNNABLE &lt;—&gt; WAITING</strong></p><ul><li><p>当前线程调用 t.join() 方法时，当前线程从RUNNABLE —&gt; WAITING</p></li><li><ul><li>注意是当前线程在t 线程对象的监视器上等待</li></ul></li><li><p>t 线程运行结束，或调用了当前线程的 interrupt() 时，当前线程从 WAITING —&gt; RUNNABLE</p></li></ul><p><strong>情况 4 RUNNABLE &lt;—&gt; WAITING</strong></p><ul><li>当前线程调用 LockSupport.park() 方法会让当前线程从 RUNNABLE —&gt; WAITING</li><li>调用 LockSupport.unpark(目标线程) 或调用了线程 的 interrupt() ，会让目标线程从 WAITING —&gt;RUNNABLE</li></ul><p><strong>情况 5 RUNNABLE &lt;—&gt; TIMED_WAITING</strong></p><p>t 线程用 synchronized(obj) 获取了对象锁后</p><ul><li><p>调用 obj.wait(long n) 方法时，t 线程从 RUNNABLE —&gt; TIMED_WAITING</p></li><li><p>t 线程等待时间超过了 n 毫秒，或调用 obj.notify() ， obj.notifyAll() ， t.interrupt() 时</p></li><li><ul><li>竞争锁成功，t 线程从 TIMED_WAITING  —&gt; RUNNABLE</li><li>竞争锁失败，t 线程从 TIMED_WAITING  —&gt; BLOCKED</li></ul></li></ul><p><strong>情况 6 RUNNABLE &lt;—&gt; TIMED_WAITING</strong></p><ul><li><p>当前线程调用 t.join(long n) 方法时，当前线程从 RUNNABLE —&gt; TIMED_WAITING</p></li><li><ul><li>注意是当前线程在t 线程对象的监视器上等待</li></ul></li><li><p>当前线程等待时间超过了 n 毫秒，或t 线程运行结束，或调用了当前线程的 interrupt() 时，当前线程从TIMED_WAITING —&gt; RUNNABLE</p></li></ul><p><strong>情况 7 RUNNABLE &lt;—&gt; TIMED_WAITING</strong></p><ul><li>当前线程调用 Thread.sleep(long n) ，当前线程从 RUNNABLE —&gt; TIMED_WAITING</li><li>当前线程等待时间超过了 n 毫秒，当前线程从     TIMED_WAITING —&gt; RUNNABLE</li></ul><p><strong>情况 8 RUNNABLE &lt;—&gt; TIMED_WAITING</strong></p><ul><li>当前线程调用 LockSupport.parkNanos(long nanos) 或 LockSupport.parkUntil(long millis)  时，当前线程从 RUNNABLE —&gt; TIMED_WAITING</li><li>调用 LockSupport.unpark(目标线程)或调用了线程 的 interrupt() ，或是等待超时，会让目标线程从TIMED_WAITING—&gt; RUNNABLE</li></ul><p><strong>情况 9 RUNNABLE &lt;—&gt; BLOCKED</strong></p><ul><li>t 线程用 synchronized(obj) 获取了对象锁时如果竞争失败，从 RUNNABLE —&gt; BLOCKED</li><li>持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有  BLOCKED 的线程重新竞争，如果其中 t 线程竞争成功，从 BLOCKED —&gt; RUNNABLE ，其它失败的线程仍然 BLOCKED</li></ul><p><strong>情况 10 RUNNABLE &lt;—&gt; TERMINATED</strong></p><p>当前线程所有代码运行完毕，进入TERMINATED</p><h2 id="多把锁"><a href="#多把锁" class="headerlink" title="多把锁"></a>多把锁</h2><p>作用：将锁的粒度细分</p><ul><li>好处，是可以增强并发度</li><li>坏处，如果一个线程需要同时获得多把锁，就容易发生死锁</li></ul><h2 id="活跃性"><a href="#活跃性" class="headerlink" title="活跃性"></a>活跃性</h2><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>有这样的情况：一个线程需要同时获取多把锁，这时就容易发生死锁<br>t1 线程 获得 A对象 锁，接下来想获取 B对象的锁 t2 线程 获得 B对象 锁，接下来想获取 A对象的锁 例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">lockA</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">lockB</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lockA) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;t1加锁A&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> ((lockB)) &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;t1加锁B&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lockB) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;t2加锁B&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> ((lockA)) &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;t2加锁A&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定位死锁"><a href="#定位死锁" class="headerlink" title="定位死锁"></a>定位死锁</h3><p>检测死锁可以使用 jconsole工具，或者使用 jps 定位进程 id，再用 jstack 定位死锁：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[21:28:29] root:~ <span class="comment"># jps</span></span><br><span class="line">12320 Jps</span><br><span class="line">22816 KotlinCompileDaemon</span><br><span class="line">33200 TestDeadLock // JVM 进程</span><br><span class="line">11508 Main</span><br><span class="line">28468 Launcher</span><br><span class="line">[21:29:12] root:~ <span class="comment">#  jstack 33200</span></span><br><span class="line">Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.91-b14 mixed mode):</span><br><span class="line">.......</span><br><span class="line">.......</span><br></pre></td></tr></table></figure><ul><li>避免死锁要注意加锁顺序</li><li>另外如果由于某个线程进入了死循环，导致其它线程一直等待，对于这种情况  linux 下可以通过 top 先定位到CPU 占用高的 Java 进程，再利用 top -Hp 进程id 来定位是哪个线程，最后再用 jstack 排查</li></ul><h3 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h3><p>活锁出现在两个线程互相改变对方的结束条件，最后谁也无法结束</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLiveLock</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 期望减到 0 退出循环</span></span><br><span class="line">            <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                sleep(<span class="number">0.2</span>);</span><br><span class="line">                count--;</span><br><span class="line">                log.debug(<span class="string">&quot;count: &#123;&#125;&quot;</span>, count);</span><br><span class="line">            &#125;</span><br><span class="line">   &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 期望超过 20 退出循环</span></span><br><span class="line">            <span class="keyword">while</span> (count &lt; <span class="number">20</span>) &#123;</span><br><span class="line">                    sleep(<span class="number">0.2</span>);</span><br><span class="line">                    count++;</span><br><span class="line">                    log.debug(<span class="string">&quot;count: &#123;&#125;&quot;</span>, count);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h3><p>很多教程中把饥饿定义为，一个线程由于优先级太低，始终得不到 CPU 调度执行，也不能够结束，饥饿的情况不易演示，讲读写锁时会涉及饥饿问题</p><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>相对于 synchronized 它具备如下特点</p><ul><li>可中断</li><li>可以设置超时时间</li><li>可以设置为公平锁</li><li>支持多个条件变量</li></ul><p>与 synchronized 一样，都支持可重入</p><p>基本语法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取锁</span></span><br><span class="line">reentrantLock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 临界区</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    reentrantLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h3><p>可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此有权利再次获取这把锁</p><p>如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;run main&quot;</span>);</span><br><span class="line">        method1();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;run method1&quot;</span>);</span><br><span class="line">        method2();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;run method2&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可打断"><a href="#可打断" class="headerlink" title="可打断"></a>可打断</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t1&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lockInterruptibly();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;等锁的过程中被打断&quot;</span>);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;获得锁&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程先获得锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    log.info(<span class="string">&quot;获得锁&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        t1.interrupt();</span><br><span class="line">        log.debug(<span class="string">&quot;执行打断&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="锁超时"><a href="#锁超时" class="headerlink" title="锁超时"></a>锁超时</h3><p>立刻失败</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t1&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!lock.tryLock()) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;获得不到锁&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// 防止 解锁</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;获得锁&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程先获得锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    log.info(<span class="string">&quot;获得锁&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>超时失败</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t1&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!lock.tryLock(<span class="number">1</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;获得不到锁&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span>; <span class="comment">// 防止 解锁</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                log.info(<span class="string">&quot;获得不到锁&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// 防止 解锁</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;获得锁&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程先获得锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    log.info(<span class="string">&quot;获得锁&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>); <span class="comment">// 设置sleep时间对tryLock的影响</span></span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h3><p>有五位哲学家，围坐在圆桌旁。</p><ul><li><p>他们只做两件事，思考和吃饭，思考一会吃口饭，吃完饭后接着思考。</p></li><li><p>吃饭时要用两根筷子吃，桌上共有 5 根筷子，每位哲学家左右手边各有一根筷子。</p></li><li><p>如果筷子被身边的人拿着，自己就得等待</p></li></ul><p>使用 tryLock 解决哲学家就餐问题</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Chopsticks</span> <span class="keyword">extends</span> <span class="title class_">ReentrantLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Chopsticks</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Chopsticks&#123;name = &quot;</span> + name + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Philosopher</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Chopsticks left;</span><br><span class="line">    <span class="keyword">private</span> Chopsticks right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Philosopher</span><span class="params">(String name, Chopsticks left, Chopsticks right)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (right.tryLock()) &#123;</span><br><span class="line">                        <span class="keyword">try</span>&#123;</span><br><span class="line">                            eat(Thread.currentThread().getName());</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            right.unlock();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    left.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        log.info(name + <span class="string">&quot; eating...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhilosopherDinner</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Chopsticks</span> <span class="variable">l1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopsticks</span>(<span class="string">&quot;l1&quot;</span>);</span><br><span class="line">        <span class="type">Chopsticks</span> <span class="variable">l2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopsticks</span>(<span class="string">&quot;l2&quot;</span>);</span><br><span class="line">        <span class="type">Chopsticks</span> <span class="variable">l3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopsticks</span>(<span class="string">&quot;l3&quot;</span>);</span><br><span class="line">        <span class="type">Chopsticks</span> <span class="variable">l4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopsticks</span>(<span class="string">&quot;l4&quot;</span>);</span><br><span class="line">        <span class="type">Chopsticks</span> <span class="variable">l5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopsticks</span>(<span class="string">&quot;l5&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Philosopher</span>(<span class="string">&quot;zhangsan&quot;</span>, l1, l2).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Philosopher</span>(<span class="string">&quot;lisi&quot;</span>, l2, l3).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Philosopher</span>(<span class="string">&quot;wangwu&quot;</span>, l3, l4).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Philosopher</span>(<span class="string">&quot;zhaoliu&quot;</span>, l4, l5).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Philosopher</span>(<span class="string">&quot;xiaoqi&quot;</span>, l5, l1).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h3><p>ReentrantLock 默认是不公平的</p><p>设置为公平锁</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>synchronized 中也有条件变量，就是我们讲原理时那个 waitSet 休息室，当条件不满足时进入 waitSet 等待</p><p>ReentrantLock 的条件变量比 synchronized 强大之处在于，它是支持多个条件变量的，这就好比</p><ul><li>synchronized     是那些不满足条件的线程都在一间休息室等消息</li><li>而 ReentrantLock     支持多间休息室，有专门等烟的休息室、专门等早餐的休息室、唤醒时也是按休息室来唤醒</li></ul><p><strong>使用要点：</strong></p><ul><li>await 前需要获得锁</li><li>await 执行后，会释放锁，进入     conditionObject 等待</li><li>await 的线程被唤醒（或打断、或超时）取重新竞争 lock     锁</li><li>竞争 lock 锁成功后，从 await 后继续执行</li></ul><p>eg：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">isFood</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">isWater</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 多条件</span></span><br><span class="line">    <span class="type">Condition</span> <span class="variable">foodCondition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="type">Condition</span> <span class="variable">waterCondition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t1&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!isFood) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;没有食物，休息&quot;</span>);</span><br><span class="line">                    foodCondition.await();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (isFood) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;有吃的，开始干活&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;没有食物，休息&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t2&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!isWater) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;没有奶茶，休息&quot;</span>);</span><br><span class="line">                    waterCondition.await();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (isWater) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;有奶茶，开始干活&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;没有奶茶，休息&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;奶茶到了噢！&quot;</span>);</span><br><span class="line">        isWater = <span class="literal">true</span>;</span><br><span class="line">        waterCondition.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;外卖到了噢！&quot;</span>);</span><br><span class="line">        isFood = <span class="literal">true</span>;</span><br><span class="line">        foodCondition.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="同步模式-顺序控制"><a href="#同步模式-顺序控制" class="headerlink" title="同步模式: 顺序控制"></a>同步模式: 顺序控制</h2><p>顺序打印</p><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">wait-notify</button></li><li class="tab"><button type="button" data-href="#test-2">park-unpark</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            log.info(<span class="string">&quot;haha&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;heihei&quot;</span>);</span><br><span class="line">            lock.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        LockSupport.park();</span><br><span class="line">        log.info(<span class="string">&quot;haha&quot;</span>);</span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        log.info(<span class="string">&quot;heihei&quot;</span>);</span><br><span class="line">        LockSupport.unpark(t1);</span><br><span class="line">    &#125;,<span class="string">&quot;t2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>循环打印</p><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">wait-notify</button></li><li class="tab"><button type="button" data-href="#test-2">park-unpark</button></li><li class="tab"><button type="button" data-href="#test-3">ReentrantLock</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">cycle</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(String name, <span class="type">int</span> curWait, <span class="type">int</span> nextWait)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cycle; ++i)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">while</span> (flag != curWait) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log.info(name);</span><br><span class="line">                flag = nextWait;</span><br><span class="line">                lock.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,name).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环打印1 wait-notify</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">    method(<span class="string">&quot;AAA&quot;</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    method(<span class="string">&quot;BBB&quot;</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    method(<span class="string">&quot;CCC&quot;</span>, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">cycle</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="keyword">private</span> Thread[] threads;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(String name, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    threads[index] = <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cycle; i++) &#123;</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            log.info(name);</span><br><span class="line">            LockSupport.unpark(nextThread());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Thread <span class="title function_">nextThread</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (threads[i] == current) &#123;</span><br><span class="line">            index = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; threads.length - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> threads[index+<span class="number">1</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> threads[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环打印2 park-unpark</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tes4</span><span class="params">()</span> &#123;</span><br><span class="line">    threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    method(<span class="string">&quot;AAA&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    method(<span class="string">&quot;BBB&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    method(<span class="string">&quot;CCC&quot;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">    LockSupport.unpark(threads[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-3"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">cycle</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">reentrantLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(String name, Condition current, Condition next)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cycle; i++) &#123;</span><br><span class="line">            reentrantLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                current.await();</span><br><span class="line">                log.info(name);</span><br><span class="line">                next.signal();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                reentrantLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,name).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环打印3 ReentrantLock</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tes5</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Condition</span> <span class="variable">a</span> <span class="operator">=</span> reentrantLock.newCondition();</span><br><span class="line">    <span class="type">Condition</span> <span class="variable">b</span> <span class="operator">=</span> reentrantLock.newCondition();</span><br><span class="line">    <span class="type">Condition</span> <span class="variable">c</span> <span class="operator">=</span> reentrantLock.newCondition();</span><br><span class="line"></span><br><span class="line">    method(<span class="string">&quot;AAA&quot;</span>, a, b);</span><br><span class="line">    method(<span class="string">&quot;BBB&quot;</span>, b, c);</span><br><span class="line">    method(<span class="string">&quot;CCC&quot;</span>, c, a);</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">    reentrantLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        a.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        reentrantLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>14种算法模式</title>
      <link href="/posts/f6a1fd2d.html"/>
      <url>/posts/f6a1fd2d.html</url>
      
        <content type="html"><![CDATA[<h2 id="14种算法模式"><a href="#14种算法模式" class="headerlink" title="14种算法模式"></a>14种算法模式</h2><p>转载自 <a href="https://mp.weixin.qq.com/s?__biz=MzI5MDUyMDIxNA==&amp;mid=2247561682&amp;idx=4&amp;sn=7088708c9cc15abecaceb8ef0812b563&amp;chksm=ec1d1c2bdb6a953d4485b29030d08368afe93c4e6c4f1366939b71427847e8c6cb2317fc2e3b&amp;mpshare=1&amp;scene=23&amp;srcid=0410SyZVECD4GjoOcQKr4P6e&amp;sharer_sharetime=1681126194635&amp;sharer_shareid=a34b1781fd870ee933b2fc38dee41cf9#rd">极市平台</a></p><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>滑动窗口模式是用于在给定数组或链表的特定窗口大小上执行所需的操作，比如寻找包含所有 1 的最长子数组。</p><p>从第一个元素开始滑动窗口并逐个元素地向右滑，并根据你所求解的问题调整窗口的长度。</p><p>在某些情况下窗口大小会保持恒定，在其它情况下窗口大小会增大或减小。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ysxnote.oss-cn-hangzhou.aliyuncs.com/imgs/posts/algorithm01.png" alt="滑动窗口" style="zoom:70%;"></p><p>下面是一些你可以用来确定给定问题可能需要滑动窗口的方法：</p><ul><li>问题的输入是一种线性数据结构，比如链表、数组或字符串</li><li>你被要求查找最长/最短的子字符串、子数组或所需的值</li></ul><p>你可以使用滑动窗口模式处理的常见问题：</p><ul><li>大小为 K  的子数组的最大和（简单）</li><li>带有 K 个不同字符的最长子字符串（中等）</li><li>寻找字符相同但排序不一样的字符串（困难）</li></ul><h3 id="二指针或迭代器"><a href="#二指针或迭代器" class="headerlink" title="二指针或迭代器"></a>二指针或迭代器</h3><p>二指针（Two Pointers）是这样一种模式：</p><p>两个指针以一前一后的模式在数据结构中迭代，直到一个或两个指针达到某种特定条件。</p><p>二指针通常在排序数组或链表中搜索配对时很有用：比如当你必须将一个数组的每个元素与其它元素做比较时。</p><p>二指针是很有用的，因为如果只有一个指针，你必须继续在数组中循环回来才能找到答案。</p><p>这种使用单个迭代器进行来回在时间和空间复杂度上都很低效——这个概念被称为「渐进分析（asymptotic analysis）」。</p><p>尽管使用 1 个指针进行暴力搜索或简单普通的解决方案也有效果，但这会沿 O(n²) 线得到一些东西。在很多情况中，二指针有助于你寻找有更好空间或运行时间复杂度的解决方案。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ysxnote.oss-cn-hangzhou.aliyuncs.com/imgs/posts/algorithm02.png" alt="双指针" style="zoom:60%;"></p><p>用于识别使用二指针的时机的方法：</p><ul><li>可用于你要处理排序数组（或链接列表）并需要查找满足某些约束的一组元素的问题</li><li>数组中的元素集是配对、三元组甚至子数组</li></ul><p>下面是一些满足二指针模式的问题：</p><ul><li>求一个排序数组的平方（简单）</li><li>求总和为零的三元组（中等）</li><li>比较包含回退（backspace）的字符串（中等）</li></ul><h3 id="快速和慢速指针"><a href="#快速和慢速指针" class="headerlink" title="快速和慢速指针"></a>快速和慢速指针</h3><p>快速和慢速指针方法也被称为 Hare &amp; Tortoise 算法，该算法会使用两个在数组（或序列/链表）中以不同速度移动的指针。该方法在处理循环链表或数组时非常有用。</p><p>通过以不同的速度进行移动（比如在一个循环链表中），该算法证明这两个指针注定会相遇。只要这两个指针在同一个循环中，快速指针就会追赶上慢速指针。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ysxnote.oss-cn-hangzhou.aliyuncs.com/imgs/posts/algorithm03.png" alt="快慢指针" style="zoom:60%;"></p><p>如何判别使用快速和慢速模式的时机？</p><ul><li>处理链表或数组中的循环的问题</li><li>当你需要知道特定元素的位置或链表的总长度时</li></ul><p>何时应该优先选择这种方法，而不是上面提到的二指针方法？</p><ul><li>有些情况不适合使用二指针方法，比如在不能反向移动的单链接链表中。使用快速和慢速模式的一个案例是当你想要确定一个链表是否为回文（palindrome）时。</li></ul><p>下面是一些满足快速和慢速指针模式的问题：</p><ul><li>链表循环（简单）</li><li>回文链表（中等）</li><li>环形数组中的循环（困难）</li></ul><h3 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a>合并区间</h3><p>合并区间模式是一种处理重叠区间的有效技术。</p><p>在很多涉及区间的问题中，你既需要找到重叠的区间，也需要在这些区间重叠时合并它们。该模式的工作方式为：</p><p>给定两个区间（a 和 b），这两个区间有 6 种不同的互相关联的方式：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ysxnote.oss-cn-hangzhou.aliyuncs.com/imgs/posts/algorithm04.png" alt="合并区间" style="zoom:80%;"></p><p>理解并识别这六种情况有助于你求解范围广泛的问题，从插入区间到优化区间合并等。</p><p>那么如何确定何时该使用合并区间模式呢？</p><ul><li>如果你被要求得到一个仅含互斥区间的列表</li><li>如果你听到了术语「重叠区间（overlapping     intervals）」</li></ul><p>合并区间模式的问题：</p><ul><li>区间交叉（中等）</li><li>最大 CPU 负载（困难）</li></ul><h3 id="循环排序"><a href="#循环排序" class="headerlink" title="循环排序"></a>循环排序</h3><p>这一模式描述了一种有趣的方法，处理的是涉及包含给定范围内数值的数组的问题。</p><p>循环排序模式一次会在数组上迭代一个数值，如果所迭代的当前数值不在正确的索引处，就将其与其正确索引处的数值交换。</p><p>你可以尝试替换其正确索引处的数值，但这会带来 O(n^2) 的复杂度，这不是最优的，因此要用循环排序模式。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ysxnote.oss-cn-hangzhou.aliyuncs.com/imgs/posts/algorithm05.png" alt="循环排序" style="zoom:100%;"></p><p>如何识别这种模式？</p><ul><li>涉及数值在给定范围内的排序数组的问题</li><li>如果问题要求你在一个排序/旋转的数组中找到缺失值/重复值/最小值</li></ul><p>循环排序模式的问题：</p><ul><li>找到缺失值（简单）</li><li>找到最小的缺失的正数值（中等）</li></ul><h3 id="原地反转链表"><a href="#原地反转链表" class="headerlink" title="原地反转链表"></a>原地反转链表</h3><p>在很多问题中，你可能会被要求反转一个链表中一组节点之间的链接。</p><p>通常而言，你需要原地完成这一任务，即使用已有的节点对象且不占用额外的内存。这就是这个模式的用武之地。</p><p>该模式会从一个指向链表头的变量（current）开始一次反转一个节点，然后一个变量（previous）将指向已经处理过的前一个节点。</p><p>以锁步的方式，在移动到下一个节点之前将其指向前一个节点，可实现对当前节点的反转。</p><p>另外，也将更新变量「previous」，使其总是指向已经处理过的前一个节点。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ysxnote.oss-cn-hangzhou.aliyuncs.com/imgs/posts/algorithm06.png" alt="反转链表" style="zoom:100%;"></p><p>如何识别使用该模式的时机：</p><ul><li>如果你被要求在不使用额外内存的前提下反转一个链表</li></ul><p>原地反转链表模式的问题：</p><ul><li><p>反转一个子列表（中等）</p></li><li><p>反转每个 K     个元素的子列表（中等）</p></li></ul><h3 id="树的宽度优先搜索（Tree-BFS）"><a href="#树的宽度优先搜索（Tree-BFS）" class="headerlink" title="树的宽度优先搜索（Tree BFS）"></a>树的宽度优先搜索（Tree BFS）</h3><p>该模式基于宽度优先搜索（BFS）技术，可遍历一个树并使用一个队列来跟踪一个层级的所有节点，之后再跳转到下一个层级。</p><p>任何涉及到以逐层级方式遍历树的问题都可以使用这种方法有效解决。</p><p>Tree BFS 模式的工作方式是：将根节点推至队列，然后连续迭代知道队列为空。在每次迭代中，我们移除队列头部的节点并「访问」该节点。在移除了队列中的每个节点之后，我们还将其所有子节点插入到队列中。</p><p>如何识别 Tree BFS 模式：</p><ul><li>如果你被要求以逐层级方式遍历（或按层级顺序遍历）一个树</li></ul><p>Tree BFS 模式的问题：</p><ul><li>二叉树层级顺序遍历（简单）</li><li>之字型遍历（Zigzag     Traversal）（中等）</li></ul><h3 id="树的深度优先搜索（Tree-DFS）"><a href="#树的深度优先搜索（Tree-DFS）" class="headerlink" title="树的深度优先搜索（Tree DFS）"></a>树的深度优先搜索（Tree DFS）</h3><p>Tree DFS 是基于深度优先搜索（DFS）技术来遍历树。</p><p>你可以使用递归（或该迭代方法的技术栈）来在遍历期间保持对所有之前的（父）节点的跟踪。</p><p>Tree DFS 模式的工作方式是从树的根部开始，如果这个节点不是一个叶节点，则需要做两件事：</p><ul><li>决定现在是处理当前的节点（pre-order），或是在处理两个子节点之间（in-order），还是在处理两个子节点之后（post-order）</li><li>为当前节点的两个子节点执行两次递归调用以处理它们</li></ul><p>如何识别 Tree DFS 模式：</p><ul><li>如果你被要求用     in-order、pre-order 或 post-order DFS 来遍历一个树</li><li>如果问题需要搜索其中节点更接近叶节点的东西</li></ul><p>Tree DFS 模式的问题：</p><ul><li><p>路径数量之和（中等）</p></li><li><p>一个和的所有路径（中等）</p></li></ul><h3 id="Two-Heaps"><a href="#Two-Heaps" class="headerlink" title="Two Heaps"></a>Two Heaps</h3><p>在很多问题中，我们要将给定的一组元素分为两部分。</p><p>为了求解这个问题，我们感兴趣的是了解一部分的最小元素以及另一部分的最大元素。这一模式是求解这类问题的一种有效方法。</p><p>该模式要使用两个堆（heap）：一个用于寻找最小元素的 Min Heap 和一个用于寻找最大元素的 Max Heap。</p><p>该模式的工作方式是：</p><p>先将前一半的数值存储到 Max Heap，这是由于你要寻找前一半中的最大数值。然后再将另一半存储到 Min Heap，因为你要寻找第二半的最小数值。在任何时候，当前数值列表的中间值都可以根据这两个 heap 的顶部元素计算得到。</p><p>识别 Two Heaps 模式的方法：</p><ul><li>在优先级队列、调度等场景中有用</li><li>如果问题说你需要找到一个集合的最小/最大/中间元素</li><li>有时候可用于具有二叉树数据结构的问题</li></ul><p>Two Heaps 模式的问题：</p><ul><li>查找一个数值流的中间值（中等）</li></ul><h3 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h3><p>很多编程面试问题都涉及到处理给定元素集合的排列和组合。</p><p>子集（Subsets）模式描述了一种用于有效处理所有这些问题的宽度优先搜索（BFS）方法。</p><p>该模式看起来是这样：</p><p>给定一个集合 [1, 5, 3]</p><ul><li>从一个空集开始：[[]]</li><li>向所有已有子集添加第一个数     (1)，从而创造新的子集：[[], [1]]</li><li>向所有已有子集添加第二个数     (5)：[[], [1], [5], [1,5]]</li><li>向所有已有子集添加第三个数     (3)：[[], [1], [5], [1,5], [3], [1,3], [5,3], [1,5,3]]</li></ul><p>下面是这种子集模式的一种视觉表示：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ysxnote.oss-cn-hangzhou.aliyuncs.com/imgs/posts/algorithm07.png" alt="子集" style="zoom:80%;"></p><p>如何识别子集模式：</p><ul><li>你需要找到给定集合的组合或排列的问题</li></ul><p>子集模式的问题：</p><ul><li>带有重复项的子集（简单）</li><li>通过改变大小写的字符串排列（中等）</li></ul><h3 id="经过修改的二叉搜索"><a href="#经过修改的二叉搜索" class="headerlink" title="经过修改的二叉搜索"></a>经过修改的二叉搜索</h3><p>只要给定了排序数组、链表或矩阵，并要求寻找一个特定元素，你可以使用的最佳算法就是二叉搜索。</p><p>这一模式描述了一种用于处理所有涉及二叉搜索的问题的有效方法。</p><p>对于一个升序的集合，该模式看起来是这样的：</p><ul><li>首先，找到起点和终点的中间位置。<pre><code>      寻找中间位置的一种简单方法是：middle = (start + end) / 2。      但这很有可能造成整数溢出，所以推荐你这样表示中间位置：middle = start + (end-start) / 2。</code></pre></li><li>如果键值（key）等于中间索引处的值，那么返回这个中间位置。</li><li>如果键值不等于中间索引处的值：</li><li>检查 key &lt;  arr[middle] 是否成立。如果成立，将搜索约简到 end = middle - 1</li><li>检查 key &gt; arr[middle]     是否成立。如果成立，将搜索约简到 end = middle + 1</li></ul><p>下面给出了这种经过修改的二叉搜索模式的视觉表示：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ysxnote.oss-cn-hangzhou.aliyuncs.com/imgs/posts/algorithm08.png" alt="变态二叉搜索树" style="zoom:80%;"></p><p>经过修改的二叉搜索模式的问题：</p><ul><li>与顺序无关的二叉搜索（简单）</li><li>在经过排序的无限数组中搜索（中等）</li></ul><h3 id="前-K-个元素"><a href="#前-K-个元素" class="headerlink" title="前 K 个元素"></a>前 K 个元素</h3><p>任何要求我们找到一个给定集合中前面的/最小的/最常出现的 K 的元素的问题都在这一模式的范围内。</p><p>跟踪 K 个元素的最佳的数据结构是 Heap。</p><p>这一模式会使用 Heap 来求解多个一次性处理一个给定元素集中 K 个元素的问题。</p><p>该模式是这样工作的：</p><ul><li>根据问题的不同，将 K     个元素插入到 min-heap 或 max-heap 中</li><li>迭代处理剩余的数，如果你找到一个比     heap 中数更大的数，那么就移除那个数并插入这个更大的数</li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ysxnote.oss-cn-hangzhou.aliyuncs.com/imgs/posts/algorithm09.png" alt="top-K" style="zoom:80%;"></p><p>这里无需排序算法，因为 heap 将为你跟踪这些元素。</p><p>如何识别前 K 个元素模式：</p><ul><li>如果你被要求寻找一个给定集合中前面的/最小的/最常出现的     K 的元素</li><li>如果你被要求对一个数值进行排序以找到一个确定元素</li></ul><p>前 K 个元素模式的问题：</p><ul><li>前面的 K 个数（简单）</li><li>最常出现的 K     个数（中等）</li></ul><h3 id="K-路合并"><a href="#K-路合并" class="headerlink" title="K 路合并"></a>K 路合并</h3><p>K 路合并能帮助你求解涉及一组经过排序的数组的问题。</p><p>当你被给出了 K 个经过排序的数组时，你可以使用 Heap 来有效地执行所有数组的所有元素的排序遍历。你可以将每个数组的最小元素推送至 Min Heap 以获得整体最小值。</p><p>在获得了整体最小值后，将来自同一个数组的下一个元素推送至 heap。</p><p>然后，重复这一过程以得到所有元素的排序遍历结果。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ysxnote.oss-cn-hangzhou.aliyuncs.com/imgs/posts/algorithm10.png" alt="K 路合并" style="zoom:80%;"></p><p>该模式看起来像这样：</p><ul><li>将每个数组的第一个元素插入  Min Heap</li><li>之后，从该 Heap 取出最小（顶部的）元素，将其加入到合并的列表。</li><li>在从 Heap     移除了最小的元素之后，将同一列表的下一个元素插入该 Heap</li><li>重复步骤 2 和  3，以排序的顺序填充合并的列表</li></ul><p>如何识别 K 路合并模式：</p><ul><li>具有排序数组、列表或矩阵的问题</li><li>如果问题要求你合并排序的列表，找到一个排序列表中的最小元素</li></ul><p>K 路合并模式的问题：</p><ul><li>合并 K  个排序的列表（中等）</li><li>找到和最大的 K 个配对（困难）</li></ul><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>拓扑排序可用于寻找互相依赖的元素的线性顺序。</p><p>比如，如果事件 B 依赖于事件 A，那么 A 在拓扑排序时位于 B 之前。</p><p>这个模式定义了一种简单方法来理解执行一组元素的拓扑排序的技术。</p><p>该模式看起来是这样的：</p><ol><li>初始化。<pre><code>     a）使用 HashMap 将图（graph）存储到邻接的列表中；     b）为了查找所有源，使用 HashMap 记录 in-degree 的数量</code></pre></li><li>构建图并找到所有顶点的     in-degree。<pre><code>        a）根据输入构建图并填充 in-degree HashMap</code></pre></li><li>寻找所有的源。<pre><code>        a）所有 in-degree 为 0 的顶点都是源，并会被存入一个队列</code></pre></li><li>排序。<pre><code>        a）对于每个源，执行以下操作：            &amp;emsp;i）将其加入到排序的列表；            &amp;emsp;ii）根据图获取其所有子节点；            &amp;emsp;iii）将每个子节点的 in-degree 减少 1；            &amp;emsp;iv）如果一个子节点的 in-degree 变为 0，将其加入到源队列。        b）重复 (a)，直到源队列为空。</code></pre></li></ol><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ysxnote.oss-cn-hangzhou.aliyuncs.com/imgs/posts/algorithm11.png" alt="拓扑排序" style="zoom:80%;"></p><p>如何识别拓扑排序模式：</p><ul><li>处理无向有环图的问题</li><li>如果你被要求以排序顺序更新所有对象</li><li>如果你有一类遵循特定顺序的对象</li></ul><h2 id="自己刷题的一点总结"><a href="#自己刷题的一点总结" class="headerlink" title="自己刷题的一点总结"></a>自己刷题的一点总结</h2><h3 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h3><p>作用：求每个固定长度区间最值。</p><p>顾名思义,单调队列即是一个单调的队列.</p><p>给定数列：{3, 1, 5, 7, 4, 2, 1}，现在要维护 区间长度为 3 的最大值。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ysxnote.oss-cn-hangzhou.aliyuncs.com/imgs/posts/algorithm12.png" alt="单调队列"></p><p>实现单调队列，主要分为三个部分：</p><ol><li>去尾操作 ：队尾元素出队列。当队列有新元素待入队，需要从队尾开始，删除影响队列单调性的元素，维护队列的单调性。(删除一个队尾元素后，就重新判断新的队尾元素) 去尾操作结束后，将该新元素入队列。</li><li>删头操作     ：队头元素出队列。判断队头元素是否在待求解的区间之内，如果不在，就将其删除。（这个很好理解呀，因为单调队列的队头元素就是待求解区间的极值）</li><li>取解操作 ：经过上面两个操作，取出     队列的头元素 ，就是 当前区间的极值</li></ol><h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><p>单调栈用途不太广泛，只处理一种典型的问题，叫做 Next Greater Element。</p><p>如何维护单调栈：</p><p>  以维护一个单调递增栈为例。当插入一个新元素时，为了维护栈内的单调性，我们将该元素与栈顶元素进行比较，若不满足单调性，就将栈顶元素弹出，不断重复，直到栈空或者满足单调性为止，最后再将该元素塞入栈顶。</p><h3 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h3><mark class="hl-label default">什么问题可以运用二分搜索算法技巧？</mark> <p>  首先，你要从题目中抽象出一个自变量 x，一个关于 x 的函数 f(x)，以及一个目标值 target。</p><p>  同时，x, f(x), target 还要满足以下条件：</p><ul><li><p>f(x) 必须是在 x 上的单调函数（单调增单调减都可以）。</p></li><li><p>题目是让你计算满足约束条件 f(x) == target 时的 x 的值。</p></li></ul><h3 id="BFS和DFS"><a href="#BFS和DFS" class="headerlink" title="BFS和DFS"></a>BFS和DFS</h3><h4 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h4><ul><li><strong>找距离某一点的最短路，但路径不唯一，最先搜索到满足条件的就是最短的路径</strong></li><li><strong>大范围的查找</strong></li><li><strong>出现<mark class="hl-label red">最短</mark> 、<mark class="hl-label red">最少</mark> 类似字眼的可以优先考虑</strong></li></ul><h4 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h4><ul><li><p><strong>目的性强的查找与搜索问题，白话就是：<mark class="hl-label red">能找出解就行</mark> </strong></p></li><li><p><strong>是否可达问题</strong></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java并发基本知识的简单介绍（一）</title>
      <link href="/posts/fb7d02da.html"/>
      <url>/posts/fb7d02da.html</url>
      
        <content type="html"><![CDATA[<h2 id="创建JAVA线程的方法">创建JAVA线程的方法</h2><p><strong>java创建线程的方式三种：</strong></p><div class="tabs" id="方式"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#方式-1">方式 1</button></li><li class="tab"><button type="button" data-href="#方式-2">方式 2</button></li><li class="tab"><button type="button" data-href="#方式-3">方式 3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="方式-1"><p>直接使用Thread</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t1&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;running&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    t1.start();</span><br><span class="line">    log.info(<span class="string">&quot;running&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="方式-2"><p>使用Runnable配合Thread</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;running&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">    t2.start();</span><br><span class="line">    log.info(<span class="string">&quot;running&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Runnable配合Thread lambda表达式写法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> ()-&gt;&#123; log.debug(<span class="string">&quot;running&quot;</span>); &#125;;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">    t2.start();</span><br><span class="line">    log.info(<span class="string">&quot;running&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="方式-3"><p>FutureTask配合Thread</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">    FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;running&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task, <span class="string">&quot;t3&quot;</span>);</span><br><span class="line">    t3.start();</span><br><span class="line">    log.info(<span class="string">&quot;running &#123;&#125;&quot;</span>, task.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p><strong>原理之 Thread 与 Runnable 的关系</strong></p><p>分析 Thread 的源码，理清它与 Runnable 的关系，都会调用如下代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (target != <span class="literal">null</span>) &#123;</span><br><span class="line">        target.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>小结</strong></p><ul><li>方法1 是把线程和任务合并在了一起，方法2 是把线程和任务分开了</li><li>用 Runnable 更容易与线程池等高级 API 配合</li><li>用 Runnable 让任务类脱离了 Thread     继承体系，更灵活</li></ul><div class="note green no-icon flat"><p><strong>调用run和start区别</strong></p><ul><li>直接调用 run 是在主线程中执行了 run，没有启动新的线程</li><li>使用 start 是启动新的线程，通过新的线程间接执行 run 中的代码</li></ul></div><h2 id="JAVA线程中常用API">JAVA线程中常用API</h2><h3 id="sleep-与-yield">sleep 与 yield</h3><p><strong>sleep</strong></p><ol><li><p>调用 sleep 会让当前线程从 Running 进入 Timed Waiting 状态（阻塞）</p></li><li><p>其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException</p></li><li><p>睡眠结束后的线程未必会立刻得到执行</p></li><li><p>建议用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性</p></li></ol><p><strong>yield</strong></p><ol><li><p>调用 yield 会让当前线程从 Running 进入 Runnable 就绪状态，然后调度执行其它线程</p></li><li><p>具体的实现依赖于操作系统的任务调度器</p></li></ol><p><strong>线程优先级</strong></p><ul><li>线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它</li><li>如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用</li></ul><p><strong>sleep与yield具体代码如下</strong></p><div class="tabs" id="test5"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test5-1">sleep</button></li><li class="tab"><button type="button" data-href="#test5-2">yield</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test5-1"><p>查看sleep线程的状态</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            log.debug(<span class="string">&quot;running&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    t.start();</span><br><span class="line">    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">    log.info(<span class="string">&quot;running &quot;</span> + t.getState());</span><br><span class="line">    t.join(); <span class="comment">// main 等待 t 运行完成再结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何唤醒sleep线程</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;running&quot;</span>);          <span class="comment">// 打断会抛出异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    t.start();</span><br><span class="line">    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">    t.interrupt(); <span class="comment">// 唤醒 t 会抛出异常</span></span><br><span class="line">    log.info(<span class="string">&quot;running &quot;</span> + t.getState());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test5-2"><p>yield函数与线程优先级的设置</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">                <span class="comment">// 让出CPU，该线程处于就绪状态，但是下次可能还是这个线程运行</span></span><br><span class="line">                <span class="comment">// Thread.yield();</span></span><br><span class="line">                System.out.println(<span class="string">&quot;111count=&quot;</span>+(++count));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;222count=&quot;</span>+(++count));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置优先级</span></span><br><span class="line">    t1.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">    t2.setPriority(Thread.MIN_PRIORITY);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    log.info(<span class="string">&quot;running &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h4 id="sleep">sleep</h4><p>在没有利用cpu来计算时，不要让while(true)空转浪费cpu,这时可以使用yield或sleep来让出cpu的使用权给其他程序</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread. s1eep(<span class="number">50</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e. printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>= 可以用wait或条件变量达到类似的效果</p><div class="note green no-icon flat"><ul><li><p>不同的是，后两种都需要加锁，并且需要相应的唤醒操作，一般适用于要进行同步的场景</p></li><li><p>sleep 适用于无需锁同步的场景</p></li></ul></div><h3 id="join">join</h3><p><strong>作用：</strong> 等待线程运行结束。</p><p>下面的程序运行时间约？<span class="hide-inline"><button type="button" class="hide-button" style="background-color:  #FF7242;color:  #fff"> 查看答案  </button><span class="hide-content">2s</span></span></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">&quot;running &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">&quot;running &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line"></span><br><span class="line">    t2.join();</span><br><span class="line">    t1.join();</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    log.info(<span class="string">&quot;running &#123;&#125;&quot;</span>, end - start);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="interrupt-方法详解">interrupt 方法详解</h3><p><strong>打断 sleep，wait，join 的线程</strong></p><p>这几个方法都会让线程进入阻塞状态，打断 sleep，wait，join 的线程, 会清空打断状态。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;running&quot;</span>);          <span class="comment">// 打断会抛出异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    t.start();</span><br><span class="line">    </span><br><span class="line">    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">    </span><br><span class="line">    t.interrupt(); <span class="comment">// 唤醒 t 会抛出异常</span></span><br><span class="line">    </span><br><span class="line">    log.info(<span class="string">&quot;running &quot;</span> + t.isInterrupted());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>打断正常运行的线程</strong></p><p>打断正常运行的线程, 不会清空打断状态</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> currentThread().isInterrupted();</span><br><span class="line">                <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;over&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    t.start();</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">    t.interrupt(); <span class="comment">// 唤醒 t 不会抛异常</span></span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">&quot;running&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>打断 park 线程</strong></p><p>打断 park 线程, 不会清空打断状态</p><p>如果打断标记已经是 true, 则 park 会失效</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;running1&quot;</span>);</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            log.debug(<span class="string">&quot;打断状态：&#123;&#125;&quot;</span>, Thread.currentThread().isInterrupted());</span><br><span class="line">            <span class="comment">// log.debug(&quot;打断状态：&#123;&#125;&quot;, Thread.currentThread().interrupted());</span></span><br><span class="line">            log.debug(<span class="string">&quot;running2&quot;</span>);</span><br><span class="line">            LockSupport.park();  <span class="comment">// 如果打断标记已经是 true, 则 park 会失效, 不会停止在这</span></span><br><span class="line">            log.debug(<span class="string">&quot;running3&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    t.start();</span><br><span class="line">    Thread.sleep(<span class="number">200</span>);</span><br><span class="line">    t.interrupt();</span><br><span class="line">    log.info(<span class="string">&quot;running&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note green no-icon flat"><p><strong>isInterrupted()与interrupted()区别</strong></p><p>isInterrupted() 判断是否被打断，<font color="red"> 不会清除打断标记 </font></p><p>interrupted() 判断当前线程是否被打断，<font color="red">会清除打断标记 </font></p></div><h3 id="两阶段终止模式-Two-Phase-Termination">两阶段终止模式 (Two Phase Termination)</h3><p><strong>要问题：</strong> 在一个线程T1中如何“优雅“终止线程T2？这里的[优雅]指的是给T2一个料理后事的机会。</p><p><strong>引用：</strong> 后台监控</p><h4 id="错误思路">错误思路</h4><p>■使用线程对象的stop(方法停止线程</p><p> stop 方法会真正杀死线程，如果这时线程锁住了共享资源，那么当它被杀死后就再也没有机会释放锁，其它线程将永远无法获取锁</p><p>■使用System.exit(int)方法停止线程</p><p> 目的仅是停止一个线程，但这种做法会让整个程序都停止</p><h4 id="正确思路">正确思路</h4><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ysxnote.oss-cn-hangzhou.aliyuncs.com/imgs/posts/two-phase.png" alt="两阶段终止模式" width="80%"><p>实现代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TwoPhaseTermination</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Thread monitor;</span><br><span class="line">    <span class="comment">// 启动监控程序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        monitor = <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;tpt1&quot;</span>)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> Thread.currentThread().isInterrupted();</span><br><span class="line">                    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                        log.debug(<span class="string">&quot;over&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">2000</span>); <span class="comment">// 情况1：在该程序睡眠过程中打断，flag==false，抛出异常，需要处理异常</span></span><br><span class="line">                        log.info(<span class="string">&quot;执行监控记录&quot;</span>);   <span class="comment">// 情况2：在该程序执行过程中打断，flag==true</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                        <span class="comment">// 情况1：重新设置打断标志，使flag==true</span></span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        monitor.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 停止监控程序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        monitor.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="主线程与守护线程">主线程与守护线程</h3><p>默认情况下，Java 进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做守护线程，只要其它非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> currentThread().isInterrupted();</span><br><span class="line">                <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;over&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 设置该线程为守护线程</span></span><br><span class="line">    t.setDaemon(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    t.start();</span><br><span class="line">    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">    log.info(<span class="string">&quot;running&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note green no-icon flat"><p><strong>注意</strong></p><p>垃圾回收器线程就是一种守护线程</p><p>Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等待它们处理完当前请求</p></div><h2 id="线程状态">线程状态</h2><p><strong><font color="red"> 五种状态</font> 这是从 <font color="red"> 操作系统</font> 层面来描述的</strong></p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ysxnote.oss-cn-hangzhou.aliyuncs.com/imgs/posts/system-status.png" alt="操作系统层面描述的五种状态" width="80%"><ul><li><p>【初始状态】仅是在语言层面创建了线程对象，还未与操作系统线程关联</p></li><li><p>【可运行状态】（就绪状态）指该线程已经被创建（与操作系统线程关联），可以由     CPU 调度执行</p></li><li><p>【运行状态】指获取了 CPU 时间片运行中的状态</p></li><li><ul><li>当 CPU      时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换</li></ul></li><li><p>【阻塞状态】</p></li><li><ul><li>如果调用了阻塞 API，如 BIO 读写文件，这时该线程实际不会用到 CPU，会导致线程上下文切换，进入【阻塞状态】</li><li>等 BIO 操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】</li><li>与【可运行状态】的区别是，对【阻塞状态】的线程来说只要它们一直不唤醒，调度器就一直不会考虑调度它们</li></ul></li><li><p>【终止状态】表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态</p></li></ul><p><strong><font color="red"> 六种状态</font> 这是从 <font color="red"> Java API 层面</font> 层面来描述的</strong></p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ysxnote.oss-cn-hangzhou.aliyuncs.com/imgs/posts/java-status.png" alt="Java API层面描述的六种状态" width="80%"><ul><li>NEW 线程刚被创建，但是还没有调用 start() 方法</li><li>RUNNABLE 当调用了 start()     方法之后，注意，Java API 层面的 RUNNABLE 状态涵盖了 操作系统 层面的【可运行状态】、【运行状态】和【阻塞状态】（由于 BIO     导致的线程阻塞，在 Java 里无法区分，仍然认为是可运行）</li><li>BLOCKED ， WAITING ，     TIMED_WAITING 都是 Java API 层面对【阻塞状态】的细分，后面会在状态转换一节详述</li><li>TERMINATED 当线程代码运行结束</li></ul><p>JAVA API六种状态展示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t1&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// log.debug(&quot;t1 running&quot;);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t2&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// log.debug(&quot;t1 running&quot;);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    t2.start();</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t3&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    t3.start();</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t4&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (MyThread3.class) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    t4.start();</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t5&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (MyThread3.class) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    t5.start();</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t6&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t3.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    t6.start();</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">&quot;t1 status: &quot;</span> + t1.getState()); <span class="comment">// NEW</span></span><br><span class="line">    log.info(<span class="string">&quot;t2 status: &quot;</span> + t2.getState()); <span class="comment">// TERMINATED</span></span><br><span class="line">    log.info(<span class="string">&quot;t3 status: &quot;</span> + t3.getState()); <span class="comment">// RUNNABLE</span></span><br><span class="line">    log.info(<span class="string">&quot;t4 status: &quot;</span> + t4.getState()); <span class="comment">// TIMED_WAITING</span></span><br><span class="line">    log.info(<span class="string">&quot;t5 status: &quot;</span> + t5.getState()); <span class="comment">// BLOCKED</span></span><br><span class="line">    log.info(<span class="string">&quot;t6 status: &quot;</span> + t6.getState()); <span class="comment">// WAITING</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些有用的网站</title>
      <link href="/posts/bcd0724d.html"/>
      <url>/posts/bcd0724d.html</url>
      
        <content type="html"><![CDATA[<h2 id="面试相关"><a href="#面试相关" class="headerlink" title="面试相关"></a>面试相关</h2><p>前言：基础知识还需要多看视频，书籍等，这些网站都是辅助。</p><p>视频推荐B站上：黑马/动力节点的基础课程</p><p>推荐一个计算机电子书网站：<a href="https://github.com/forthespada/CS-Books">forthespada/CS-Books: 🔥🔥超过1000本的计算机经典书籍、个人笔记资料以及本人在各平台发表文章中所涉及的资源等。书籍资源包括C/C++、Java、Python、Go语言、数据结构与算法、操作系统、后端架构、计算机系统知识、数据库、计算机网络、设计模式、前端、汇编以及校招社招各种面经~ (github.com)</a></p><h3 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h3><p>⭐⭐⭐⭐⭐ <a href="https://xiaolincoding.com/">小林coding (xiaolincoding.com)</a></p><p>⭐⭐⭐⭐ <a href="https://subingwen.cn/">爱编程的大丙 (subingwen.cn)</a></p><p>数据结构可视化：</p><ul><li><p><a href="https://visualgo.net/zh">数据结构和算法动态可视化 (Chinese) - VisuAlgo</a></p></li><li><p><a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">Data Structure Visualization (usfca.edu)</a></p></li></ul><p>算法刷题 </p><ul><li><p><a href="https://codetop.cc/home">CodeTop企业题库</a></p></li><li><p><a href="https://leetcode.cn/problemset/all/">题库 - 力扣 (LeetCode) 全球极客挚爱的技术成长平台</a></p></li><li><p><a href="https://labuladong.gitee.io/algo/">labuladong 的算法小抄 :: labuladong的算法小抄 (gitee.io)</a>  可能存在部分收费的情况</p></li></ul><h3 id="C-C"><a href="#C-C" class="headerlink" title="C/C++"></a>C/C++</h3><p>⭐⭐⭐⭐⭐ <a href="http://www.stibel.icu/md/guide/guide-overview.html">♥C++ 全栈知识体系 导航地图♥ | C++ 全栈知识体系 (stibel.icu)</a></p><p>⭐⭐⭐⭐ <a href="https://subingwen.cn/">爱编程的大丙 (subingwen.cn)</a></p><p>⭐⭐⭐⭐ <a href="https://interviewguide.cn/">阿秀的学习笔记 (interviewguide.cn)</a></p><p>⭐⭐⭐ <a href="https://interview.huihut.com/#/">interview (huihut.com)</a></p><p>项目：</p><ul><li><p>基础</p><ul><li><p><a href="https://github.com/fixbug666/chatserver">chatserver: 可以工作在nginx tcp负载均衡环境中的集群聊天服务器和客户端源码 基于muduo实现 (github.com)</a></p></li><li><p><a href="https://github.com/huboy-zhao/MyRPC">MyRPC: 基于protobuf、muduo、zookeeper的分布式网络通信框架 (github.com)</a></p></li></ul></li></ul><ul><li><p>进阶</p><ul><li><a href="https://github.com/sylar-yin/sylar">sylar: C++高性能分布式服务器框架,webserver,websocket server,自定义tcp_server（包含日志模块，配置模块，线程模块，协程模块，协程调度模块，io协程调度模块，hook模块，socket模块，bytearray序列化，http模块，TcpServer模块，Websocket模块，Https模块等, Smtp邮件模块, MySQL, SQLite3, ORM,Redis,Zookeeper) (github.com)</a></li></ul></li></ul><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><p>⭐⭐⭐⭐⭐ <a href="https://www.pdai.tech/">| Java 全栈知识体系 (pdai.tech)</a></p><p>⭐⭐⭐⭐⭐ <a href="https://bugstack.cn/">bugstack 虫洞栈</a></p><p>⭐⭐⭐⭐ <a href="https://cswiki.top/">CS-Wiki (cswiki.top)</a></p><p>项目： 我还没做过😂，就不推荐了</p><h2 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h2><p>没做过人工智能相关的项目，只写过相关论文，推荐一些看热点文章的网站（<a href="https://scholar.google.com">谷歌学术</a>/<a href="https://arxiv.org/search/cs">预印本</a>就不单独列出了）</p><ul><li><a href="https://www.jiqizhixin.com/columns">专栏 | 机器之心 (jiqizhixin.com)</a></li><li><p><a href="https://www.aminer.cn/">AMiner - AI赋能科技情报挖掘-学术搜索-论文检索-论文专利-文献追踪-学者画像</a></p></li><li><p><a href="https://www.cvmart.net/community">极市开发者社区-高质量视觉算法开发者社区 (cvmart.net)</a></p></li><li><p><a href="https://www.yanxishe.com/">AI研习社 - 研习AI产学研新知，助力AI学术开发者成长。 (yanxishe.com)</a></p></li></ul><h2 id="工具相关"><a href="#工具相关" class="headerlink" title="工具相关"></a>工具相关</h2><ul><li><p>原版软件信息收录站点：<a href="https://msdn.itellyou.cn/">MSDN, 我告诉你 - 做一个安静的工具站 (itellyou.cn)</a></p></li><li><p>各种软件下载：<a href="https://en.taiwebs.com/?lang=CN">Share and Download Free Software - Updated daily (taiwebs.com)</a></p></li><li><p>懂得都懂：<a href="https://github.com/anaer/Sub">anaer/Sub: 节点 (github.com)</a></p></li><li><p>虚拟电话号码：<a href="https://sms-activate.org/">SMS-Activate是在线接受短信的虚拟号码服务</a></p></li><li><p>目前地表最强AI模型：<a href="https://chat.openai.com/">ChatGPT</a></p></li><li><p>AI作画：</p><ul><li><p><a href="https://lexica.art/aperture">Lexica Aperture</a></p></li><li><p><a href="https://beta.dreamstudio.ai/dream">DreamStudio</a></p></li><li><p><a href="https://draft.art/drawing">Draft</a></p></li></ul></li></ul><h2 id="其他（太强了）"><a href="#其他（太强了）" class="headerlink" title="其他（太强了）"></a>其他（太强了）</h2><ul><li><p><a href="https://www.sjsdh.cn/">搜奇导航 | 专注于分享简单实用的网址导航 (sjsdh.cn)</a></p></li><li><p><a href="https://www.iiice.cn/#/">下次一定 - 专门为白嫖怪开发的宝藏网站 (iiice.cn)</a></p></li><li><a href="https://lkssite.vip/">LKs - 良心到难以置信的网站推荐 (lkssite.vip)</a></li><li>壁纸：<a href="https://wallhaven.cc/">wallhaven</a></li><li>复古小游戏：<a href="https://www.yikm.net/">小霸王，其乐无穷 。红白机，FC在线游戏，街机游戏，街机在线，NES games，NES games online，Super Mario (yikm.net)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Site </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>This a Hexo Demo</title>
      <link href="/posts/d3761ba4.html"/>
      <url>/posts/d3761ba4.html</url>
      
        <content type="html"><![CDATA[<h2 id="快速搭建自己的博客参考下面链接"><a href="#快速搭建自己的博客参考下面链接" class="headerlink" title="快速搭建自己的博客参考下面链接"></a>快速搭建自己的博客参考下面链接</h2><p><a href="https://zhuanlan.zhihu.com/p/26625249">GitHub+Hexo 搭建个人网站详细教程 - 知乎 (zhihu.com)</a></p><h2 id="配置图床使用阿里云OSS-PicGo"><a href="#配置图床使用阿里云OSS-PicGo" class="headerlink" title="配置图床使用阿里云OSS + PicGo"></a>配置图床使用阿里云OSS + PicGo</h2><p><a href="https://www.aliyun.com/product/oss">对象存储 OSS<em>云存储服务</em>企业数据管理_存储-阿里云 (aliyun.com)</a></p><p><a href="https://github.com/Molunerfinn/PicGo/releases">Releases · Molunerfinn/PicGo (github.com)</a></p><p><a href="https://blog.csdn.net/weixin_43571641/article/details/126534731">阿里云OSS图床搭建教程_阿里云图床_Luckysec的博客-CSDN博客</a></p><h2 id="以下都是测试，无实际意义"><a href="#以下都是测试，无实际意义" class="headerlink" title="以下都是测试，无实际意义"></a>以下都是测试，无实际意义</h2><h3 id="代码样式测试"><a href="#代码样式测试" class="headerlink" title="代码样式测试"></a>代码样式测试</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    std::sout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="标签外挂测试"><a href="#标签外挂测试" class="headerlink" title="标签外挂测试"></a>标签外挂测试</h3><h4 id="test1"><a href="#test1" class="headerlink" title="test1"></a>test1</h4><div class="gallery-group-main">    <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ysxnote.oss-cn-hangzhou.aliyuncs.com/imgs/posts/wallhaven.png" alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">壁纸</div>  <p>收藏的一些壁纸</p>  <a href="https://wallhaven.cc"></a>  </figcaption>  </figure>  </div><h4 id="test2-3"><a href="#test2-3" class="headerlink" title="test2/3"></a>test2/3</h4><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">test 1</button></li><li class="tab"><button type="button" data-href="#test-2">test 2</button></li><li class="tab"><button type="button" data-href="#test-3">test 3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p>哪个英文字母最酷？ <span class="hide-inline"><button type="button" class="hide-button" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">因为西装裤(C装酷)</span>&lt;/span&gt;</span></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>查看答案</p><div class="hide-block"><button type="button" class="hide-button" style>查看答案    </button><div class="hide-content"><p>傻子，怎么可能有答案</p></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-3"><details class="toggle"><summary class="toggle-button" style>Butterfly安装方法</summary><div class="toggle-content"><p>在你的博客根目录里<br>git clone -b master <a href="https://github.com/jerryc127/hexo-theme-butterfly.git">https://github.com/jerryc127/hexo-theme-butterfly.git</a> themes/Butterfly<br>如果想要安装比较新的dev分支，可以<br>git clone -b dev <a href="https://github.com/jerryc127/hexo-theme-butterfly.git">https://github.com/jerryc127/hexo-theme-butterfly.git</a> themes/Butterfly</p></div></details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h4 id="test4"><a href="#test4" class="headerlink" title="test4"></a>test4</h4><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  pie    title Key elements in Product X    &quot;Calcium&quot; : 42.96    &quot;Potassium&quot; : 50.05    &quot;Magnesium&quot; : 10.01    &quot;Iron&quot; :  5  </pre></div><h4 id="test5"><a href="#test5" class="headerlink" title="test5"></a>test5</h4><p>这是我的网站, 点击这个按钮 <a class="btn-beautify green larger" href="https://ysxnote.cn" title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a></p><h4 id="test6"><a href="#test6" class="headerlink" title="test6"></a>test6</h4><p>你看我长得漂亮不</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ysxnote.oss-cn-hangzhou.aliyuncs.com/imgs/posts/beautiful.jpg" alt></p><p>我觉得很漂亮 <img class="inline-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ysxnote.oss-cn-hangzhou.aliyuncs.com/imgs/posts/youAreBeautiful.png" style="height:150px"></p><h4 id="test7"><a href="#test7" class="headerlink" title="test7"></a>test7</h4><p>臣亮言：<mark class="hl-label default">先帝</mark> 创业未半，而<mark class="hl-label blue">中道崩殂</mark> 。今天下三分，<mark class="hl-label pink">益州疲敝</mark> ，此诚<mark class="hl-label red">危急存亡之秋</mark> 也！然侍衞之臣，不懈于内；<mark class="hl-label purple">忠志之士</mark> ，忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气；不宜妄自菲薄，引喻失义，以塞忠谏之路也。<br>宫中、府中，俱为一体；陟罚臧否，不宜异同。若有<mark class="hl-label orange">作奸</mark> 、<mark class="hl-label green">犯科</mark> ，及为忠善者，宜付有司，论其刑赏，以昭陛下平明之治；不宜偏私，使内外异法也。</p><h4 id="test8"><a href="#test8" class="headerlink" title="test8"></a>test8</h4><div class="timeline green"><div class="timeline-item headline"><div class="timeline-item-title"><div class="item-circle"><p>2023</p></div></div></div><div class="timeline-item"><div class="timeline-item-title"><div class="item-circle"><p>04-10</p></div></div><div class="timeline-item-content"><p>这是测试页面</p></div></div></div><h4 id="test9"><a href="#test9" class="headerlink" title="test9"></a>test9</h4><div class="note no-icon simple"><p>默认 提示块标签</p></div><div class="note default no-icon simple"><p>default 提示块标签</p></div><div class="note primary no-icon simple"><p>primary 提示块标签</p></div><div class="note success no-icon simple"><p>success 提示块标签</p></div><div class="note info no-icon simple"><p>info 提示块标签</p></div><div class="note warning no-icon simple"><p>warning 提示块标签</p></div><div class="note danger no-icon simple"><p>danger 提示块标签</p></div><p>=====</p><div class="note flat"><p>默认 提示块标签</p></div><div class="note default flat"><p>default 提示块标签</p></div><div class="note primary flat"><p>primary 提示块标签</p></div><div class="note success flat"><p>success 提示块标签</p></div><div class="note info flat"><p>info 提示块标签</p></div><div class="note warning flat"><p>warning 提示块标签</p></div><div class="note danger flat"><p>danger 提示块标签</p></div><p>=====</p><div class="note no-icon simple"><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue no-icon simple"><p>2021年快到了….</p></div><div class="note pink no-icon simple"><p>小心开车 安全至上</p></div><div class="note red no-icon simple"><p>这是三片呢？还是四片？</p></div><div class="note orange no-icon simple"><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple no-icon simple"><p>剪刀石头布</p></div><div class="note green no-icon simple"><p>前端最讨厌的浏览器</p></div><p>=====</p><div class="note icon-padding flat"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了….</p></div><div class="note pink icon-padding flat"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding flat"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding flat"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding flat"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding flat"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>=====</p><div class="note icon-padding flat"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了….</p></div><div class="note pink icon-padding flat"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding flat"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding flat"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding flat"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding flat"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><h4 id="test10"><a href="#test10" class="headerlink" title="test10"></a>test10</h4><div class="flink"><div class="flink-name">友情链接</div><div class="flink-desc">那些人，那些事</div> <div class="flink-list">          <div class="flink-list-item">            <a href="https://jerryc.me/" title="JerryC" target="_blank">              <div class="flink-item-icon">                <img class="no-lightbox" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://jerryc.me/img/avatar.png" onerror="this.onerror=null;this.src="/img/friend_404.gif"" alt="JerryC">              </div>              <div class="flink-item-name">JerryC</div>               <div class="flink-item-desc" title="今日事,今日毕">今日事,今日毕</div>            </a>          </div>          <div class="flink-list-item">            <a href="https://hexo.io/zh-tw/" title="Hexo" target="_blank">              <div class="flink-item-icon">                <img class="no-lightbox" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg" onerror="this.onerror=null;this.src="/img/friend_404.gif"" alt="Hexo">              </div>              <div class="flink-item-name">Hexo</div>               <div class="flink-item-desc" title="快速、简单且强大的网志框架">快速、简单且强大的网志框架</div>            </a>          </div></div><div class="flink-name">网站</div><div class="flink-desc">值得推荐的网站</div> <div class="flink-list">          <div class="flink-list-item">            <a href="https://www.youtube.com/" title="Youtube" target="_blank">              <div class="flink-item-icon">                <img class="no-lightbox" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png" onerror="this.onerror=null;this.src="/img/friend_404.gif"" alt="Youtube">              </div>              <div class="flink-item-name">Youtube</div>               <div class="flink-item-desc" title="视频网站">视频网站</div>            </a>          </div>          <div class="flink-list-item">            <a href="https://www.weibo.com/" title="Weibo" target="_blank">              <div class="flink-item-icon">                <img class="no-lightbox" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png" onerror="this.onerror=null;this.src="/img/friend_404.gif"" alt="Weibo">              </div>              <div class="flink-item-name">Weibo</div>               <div class="flink-item-desc" title="中国最大社交分享平台">中国最大社交分享平台</div>            </a>          </div>          <div class="flink-list-item">            <a href="https://twitter.com/" title="Twitter" target="_blank">              <div class="flink-item-icon">                <img class="no-lightbox" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png" onerror="this.onerror=null;this.src="/img/friend_404.gif"" alt="Twitter">              </div>              <div class="flink-item-name">Twitter</div>               <div class="flink-item-desc" title="社交分享平台">社交分享平台</div>            </a>          </div></div></div>]]></content>
      
      
      <categories>
          
          <category> Other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>